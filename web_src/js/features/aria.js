import $ from 'jquery';

let ariaIdCounter = 0;

function generateAriaId() {
  return `_aria_auto_id_${ariaIdCounter++}`;
}

// make the items has role=option, and add an id if there wasn't one yet.
function prepareList($list) {
  const $items = $list.find('> .item');
  $items.each((_, item) => {
    if (!$(item).attr('id')) $(item).attr('id', generateAriaId());
    $(item).attr({'role': 'option', 'tabindex': '-1'});
    $(item).find('a').attr('tabindex', '-1'); // as above, the elements inside the dropdown menu item should not be focusable, the focus should always be on the dropdown primary element.
    if ($(item).hasClass('selected')) $(item).attr('aria-current', 'true');
    $(item).find('a.item').each((_, it) => {
      if ($(it).hasClass('checked')) {
        it.attr('aria-checked', 'true');
      }
    });
  });
  $list.find('> .header').each((_, header) => { $(header).attr('role', 'none') });
  $list.find('> .divider').each((_, divider) => { $(divider).attr('role', 'none') });
}

// clean indentation data included as text nodes without content but spaces and newlines
// this problem is generated by an inline containers as `span` used without a proper content container, so the empty text nodes with newlines provenient from the templates produced these nodes in the DOM which generates noises in screen readers.
function cleanVoidTextContent($container) {
  for (const el of $container.get(0).childNodes) {
    if (el.nodeType === Node.TEXT_NODE && el.textContent.trim() === '') {
      el.remove();
    }
  }
}

function attachOneDropdownAria($dropdown) {
  if ($dropdown.data('module-dropdown') === undefined || $dropdown.attr('data-aria-attached')) return;
  $dropdown.attr('data-aria-attached', 1);

  // Dropdown has 2 different focusing behaviors
  // * with search input: the input is focused, and it works with aria-activedescendant pointing another sibling element.
  // * without search input (but the readonly text), the dropdown itself is focused. then the aria-activedescendant points to the element inside dropdown
  // Some desktop screen readers may change the focus, but dropdown requires that the focus must be on its primary element, then they don't work well.

  // Expected user interactions for dropdown with aria support:
  // * user can use Tab to focus in the dropdown, then the dropdown menu (list) will be shown
  // * user presses Tab on the focused dropdown to move focus to next sibling focusable element (but not the menu item)
  // * user can use arrow key Up/Down to navigate between menu items
  // * when user presses Enter:
  //    - if the menu item is clickable (eg: <a>), then trigger the click event
  //    - otherwise, the dropdown control (low-level code) handles the Enter event, hides the dropdown menu

  // TODO: multiple selection is not supported yet.

  // find search input
  const $textSearch = $dropdown.find('input.search').eq(0);
  const $focusable = $textSearch.length ? $textSearch : $dropdown; // the primary element for focus, see comment above

  // remove empty text to avoid screen reader noise
  cleanVoidTextContent($dropdown);

  // when the menu items are loaded from AJAX requests, the items are created dynamically
  // custom build menu function to add roles dynamicaly
  const setup = $dropdown.data('module-dropdown').internal('setup');
  setup.menu = function(values) {
    const $menu = $dropdown.children($dropdown.data('module-dropdown').setting('selector').menu);
    $menu.html($.fn.dropdown.settings.templates.menu(values, $dropdown.data('module-dropdown').setting('fields'), $dropdown.data('module-dropdown').setting('preserveHTML'), $dropdown.data('module-dropdown').setting('className')));
    prepareList($menu);
  };
  $dropdown.data('module-dropdown').internal('setup', setup);

  // use tooltip's content as aria-label if there is no aria-label
  if ($dropdown.hasClass('tooltip') && $dropdown.attr('data-content') && !$dropdown.attr('aria-label')) {
    $dropdown.attr('aria-label', $dropdown.attr('data-content'));
  }

  // prepare dropdown menu list popup
  const $menu = $dropdown.find('> .menu');
  // prepare list items
  prepareList($menu);
  // prepare widget
  $dropdown.attr({
    'role': 'combobox',
    'aria-haspopup': 'listbox',
    'aria-expanded': 'false',
  });
  // prepare label
  const $label = $dropdown.find('> .text');
  if ($label.length) {
    cleanVoidTextContent($label);
    $label.attr('role', 'none');
    $label.attr('id', generateAriaId());
    $dropdown.attr('aria-details', $label.attr('id'));
  } else if ($dropdown.find('> a').length) {
    $dropdown.find('> a').attr('aria-hidden', 'true');
  }
  // prepare filter input
  const $filter = $dropdown.find('> .menu > .search').eq(0);
  let $list = $menu;
  if ($filter.length) {
    const $header = $menu.find('> .header:first');
    const $icon = $filter.find('> i.icon');
    $icon.attr({
      'role': 'none',
      'aria-hidden': 'true',
    });
    const $input = $filter.find('> input');
    // prepare searchbox
    $input.attr('role', 'searchbox');
    $input.attr('aria-multiline', 'false');
    $input.attr('aria-autocomplete', 'inline');
    $input.attr('tabindex', '0');
    $input.attr('id', generateAriaId());
    $list = $('<div></div>');
    $filter.after($list);
    $list.attr('id', generateAriaId());
    $list.attr('role', 'listbox');
    $list.attr('aria-multiselectable', 'false'); // TODO: consider multiple selection
    $list.attr('aria-label', $header.text());
    $dropdown.attr('aria-controls', $list.attr('id'));
    const _ids = [];
    $menu.find('> .item').each((_, opt) => { // TODO: make groups from pairs divider+header
      _ids.push($(opt).attr('id'));
    });
    $list.attr('aria-owns', _ids.join(' '));
  } else {
    $menu.attr('id', generateAriaId());
    $menu.attr('role', 'listbox');
    $menu.attr('aria-multiselectable', 'false');
    $dropdown.attr('aria-controls', $menu.attr('id'));
  }
  // prepare search input
  if ($textSearch.length) {
    $textSearch.attr('role', 'searchbox');
    $textSearch.attr('aria-multiline', 'false');
    $textSearch.attr('tabindex', '0');
    $dropdown.find('.search > i.icon').attr({
      'role': 'none',
      'aria-hidden': 'true',
    });
  }
  // mark active descendant
  const $active = $menu.find('> .item.active');
  if ($active.length) {
    $focusable.attr('aria-activedescendant', $active.attr('id')); // FIXME: dynamic list doesn't have a setter for this
    $active.attr('aria-current', 'true');
  }
  // when showing, it has class: ".animating.in"
  // when hiding, it has class: ".visible.animating.out"
  const isMenuVisible = () => ($menu.hasClass('visible') && !$menu.hasClass('out')) || $menu.hasClass('in');

  // update aria attributes according to current active/selected item
  const refreshAria = () => {
    $dropdown.dropdown('hide others'); // hide others opened dropdowns which lost focus by speed TABs
    const menuVisible = isMenuVisible();
    $dropdown.attr('aria-expanded', menuVisible ? 'true' : 'false');

    // if there is an active item, use it (the user is navigating between items)
    // otherwise use the "selected" for combobox (for the last selected item)
    const $active = $menu.find('> .item.active, > .item.selected');

    // if there is an active item, use its id. if no active item, then the empty string is set
    $focusable.attr('aria-activedescendant', $active.attr('id'));
    $active.attr('aria-current', 'true');
  };

  $dropdown.on('keydown', (e) => {
    // here it must use keydown event before dropdown's keyup handler, otherwise there is no Enter event in our keyup handler
    if (e.key === 'Enter' || e.key === ' ') {
      let $item = $dropdown.dropdown('get item', $dropdown.dropdown('get value'));
      if (!$item) $item = $menu.find('> .item.selected'); // when dropdown filters items by input, there is no "value", so query the "selected" item
      // if the selected item is clickable, then trigger the click event.
      // we can not click any item without check, because Fomantic code might also handle the Enter event. that would result in double click.
      if ($item && ($item.is('a') || $item.hasClass('js-aria-clickable'))) $item[0].click();
    }
  });

  // use setTimeout to run the refreshAria in next tick (to make sure the Fomantic UI code has finished its work)
  // do not return any value, jQuery has return-value related behaviors.
  // when the popup is hiding, it's better to have a small "delay", because there is a Fomantic UI animation
  // without the delay for hiding, the UI will be somewhat laggy and sometimes may get stuck in the animation.
  const deferredRefreshAria = (delay = 0) => { setTimeout(refreshAria, delay) };
  $dropdown.on('keyup', (e) => {
    if (e.key.startsWith('Arrow') || e.key === 'TAB') {
      deferredRefreshAria();
    } else if (e.key === 'ESC') {
      $dropdown.dropdown('hide');
      deferredRefreshAria();
    }
  });

  // if the dropdown has been opened by focus, do not trigger the next click event again.
  // otherwise the dropdown will be closed immediately, especially on Android with TalkBack
  // * desktop event sequence: mousedown -> focus -> mouseup -> click
  // * mobile event sequence: focus -> mousedown -> mouseup -> click
  // Fomantic may stop propagation of blur event, use capture to make sure we can still get the event
  let ignoreClickPreEvents = 0, ignoreClickPreVisible = 0;
  $dropdown[0].addEventListener('mousedown', () => {
    ignoreClickPreVisible += isMenuVisible() ? 1 : 0;
    ignoreClickPreEvents++;
  }, true);
  $dropdown[0].addEventListener('focus', () => {
    ignoreClickPreVisible += isMenuVisible() ? 1 : 0;
    ignoreClickPreEvents++;
    deferredRefreshAria();
  }, true);
  $dropdown[0].addEventListener('blur', () => {
    ignoreClickPreVisible = ignoreClickPreEvents = 0;
    deferredRefreshAria(100);
  }, true);
  $dropdown[0].addEventListener('mouseup', () => {
    setTimeout(() => {
      ignoreClickPreVisible = ignoreClickPreEvents = 0;
      deferredRefreshAria(100);
    }, 0);
  }, true);
  $dropdown[0].addEventListener('click', (e) => {
    if (isMenuVisible() &&
      ignoreClickPreVisible !== 2 && // dropdown is switch from invisible to visible
      ignoreClickPreEvents === 2 // the click event is related to mousedown+focus
    ) {
      e.stopPropagation(); // if the dropdown has been opened by focus, do not trigger the next click event again
    }
    ignoreClickPreEvents = ignoreClickPreVisible = 0;
  }, true);
}

export function attachDropdownAria($dropdowns) {
  $dropdowns.each((_, e) => attachOneDropdownAria($(e)));
}

function attachCheckboxAria($checkboxes) {
  $checkboxes.checkbox();

  // Fomantic UI checkbox needs to be something like: <div class="ui checkbox"><label /><input /></div>
  // It doesn't work well with <label><input />...</label>
  // To make it work with aria, the "id"/"for" attributes are necessary, so add them automatically if missing.
  // In the future, refactor to use native checkbox directly, then this patch could be removed.
  for (const el of $checkboxes) {
    const label = el.querySelector('label');
    const input = el.querySelector('input');
    if (!label || !input || input.getAttribute('id')) continue;
    const id = generateAriaId();
    input.setAttribute('id', id);
    label.setAttribute('for', id);
  }
}
export function initAria() {
  attachDropdownAria($('.ui.dropdown:not(.custom)'));
  attachCheckboxAria($('.ui.checkbox'));
}
