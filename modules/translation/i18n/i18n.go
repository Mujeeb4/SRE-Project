// Copyright 2022 The Gitea Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

package i18n

import (
	"errors"
	"fmt"
	"os"
	"reflect"
	"sync"
	"time"

	"code.gitea.io/gitea/modules/log"
	"code.gitea.io/gitea/modules/setting"

	"gopkg.in/ini.v1"
)

var (
	ErrLocaleAlreadyExist = errors.New("lang already exists")

	DefaultLocales = NewLocaleStore(true)
)

type locale struct {
	// This mutex will be set if we have live-reload enabled (e.g. dev mode)
	reloadMu *sync.RWMutex

	store    *LocaleStore
	langName string

	idxToMsgMap map[int]string // the map idx is generated by store's trKeyToIdxMap

	sourceFileName      string
	sourceFileInfo      os.FileInfo
	lastReloadCheckTime time.Time
}

type LocaleStore struct {
	// This mutex will be set if we have live-reload enabled (e.g. dev mode)
	reloadMu *sync.RWMutex

	langNames []string
	langDescs []string

	// these need to be locked when live-reloading
	localeMap     map[string]*locale
	trKeyToIdxMap map[string]int

	defaultLang string
}

func NewLocaleStore(isProd bool) *LocaleStore {
	store := &LocaleStore{localeMap: make(map[string]*locale), trKeyToIdxMap: make(map[string]int)}
	if !isProd {
		store.reloadMu = &sync.RWMutex{}
	}
	return store
}

// AddLocaleByIni adds locale by ini into the store
// if source is a string, then the file is loaded. In dev mode, this file will be checked for live-reloading
// if source is a []byte, then the content is used
func (store *LocaleStore) AddLocaleByIni(langName, langDesc string, source interface{}) error {
	if store.reloadMu != nil {
		store.reloadMu.Lock()
		defer store.reloadMu.Unlock()
	}
	if _, ok := store.localeMap[langName]; ok {
		return ErrLocaleAlreadyExist
	}

	l := &locale{store: store, langName: langName}
	if store.reloadMu != nil {
		l.reloadMu = &sync.RWMutex{}
		l.reloadMu.Lock()
		defer l.reloadMu.Unlock()
	}

	if fileName, ok := source.(string); ok {
		l.sourceFileName = fileName
		l.sourceFileInfo, _ = os.Stat(fileName) // live-reload only works for regular files. the error can be ignored
	}

	store.langNames = append(store.langNames, langName)
	store.langDescs = append(store.langDescs, langDesc)
	store.localeMap[l.langName] = l

	return store.reloadLocaleByIni(langName, source)
}

// store.reloadMu and l.reloadMu must be locked if it exists before calling this function
// this function arguably belongs to locale rather than store but both need to be locked
func (store *LocaleStore) reloadLocaleByIni(langName string, source interface{}) error {
	iniFile, err := ini.LoadSources(ini.LoadOptions{
		IgnoreInlineComment:         true,
		UnescapeValueCommentSymbols: true,
	}, source)
	if err != nil {
		return fmt.Errorf("unable to load ini: %w", err)
	}
	iniFile.BlockMode = false

	l := store.localeMap[langName]
	l.idxToMsgMap = make(map[int]string)

	for _, section := range iniFile.Sections() {
		for _, key := range section.Keys() {

			var trKey string
			if section.Name() == "" || section.Name() == "DEFAULT" {
				trKey = key.Name()
			} else {
				trKey = section.Name() + "." + key.Name()
			}

			// Instead of storing the key strings in multiple different maps we compute a idx which will act as numeric code for key
			// This reduces the size of the locale idxToMsgMaps
			idx, ok := store.trKeyToIdxMap[trKey]
			if !ok {
				idx = len(store.trKeyToIdxMap)
				store.trKeyToIdxMap[trKey] = idx
			}
			l.idxToMsgMap[idx] = key.Value()
		}
	}
	iniFile = nil
	return nil
}

func (store *LocaleStore) HasLang(langName string) bool {
	if store.reloadMu != nil {
		store.reloadMu.RLock()
		defer store.reloadMu.RUnlock()
	}

	_, ok := store.localeMap[langName]
	return ok
}

func (store *LocaleStore) ListLangNameDesc() (names, desc []string) {
	return store.langNames, store.langDescs
}

// SetDefaultLang sets default language as a fallback
func (store *LocaleStore) SetDefaultLang(lang string) {
	store.defaultLang = lang
}

// Tr translates content to target language. fall back to default language.
func (store *LocaleStore) Tr(lang, trKey string, trArgs ...interface{}) string {
	if store.reloadMu != nil {
		store.reloadMu.RLock()
	}

	l, ok := store.localeMap[lang]
	if !ok {
		l, ok = store.localeMap[store.defaultLang]
	}
	if store.reloadMu != nil {
		store.reloadMu.RUnlock()
	}
	if ok {
		return l.Tr(trKey, trArgs...)
	}
	return trKey
}

// this function will assume that the l.reloadMu has been RLocked if it already exists
func (l *locale) reloadIfNeeded() {
	if l.store.reloadMu == nil {
		return
	}

	now := time.Now()
	if now.Sub(l.lastReloadCheckTime) < time.Second || l.sourceFileInfo == nil || l.sourceFileName == "" {
		return
	}

	l.reloadMu.RUnlock()
	l.reloadMu.Lock() // (NOTE: a pre-emption can occur between these two locks so we need to recheck)

	if now.Sub(l.lastReloadCheckTime) < time.Second || l.sourceFileInfo == nil || l.sourceFileName == "" {
		l.reloadMu.Unlock()
		l.reloadMu.RLock()
		return
	}

	l.lastReloadCheckTime = now
	sourceFileInfo, err := os.Stat(l.sourceFileName)
	if err != nil || sourceFileInfo.ModTime().Equal(l.sourceFileInfo.ModTime()) {
		l.reloadMu.Unlock()
		l.reloadMu.RLock()
		return
	}

	l.store.reloadMu.Lock()
	err = l.store.reloadLocaleByIni(l.langName, l.sourceFileName)
	l.store.reloadMu.Unlock()

	if err == nil {
		l.sourceFileInfo = sourceFileInfo
	} else {
		log.Error("unable to live-reload the locale file %q, err: %v", l.sourceFileName, err)
	}

	l.reloadMu.Unlock()
	l.reloadMu.RLock()
}

// Tr translates content to locale language. fall back to default language.
func (l *locale) Tr(trKey string, trArgs ...interface{}) string {
	if l.reloadMu != nil {
		l.reloadMu.RLock()
		defer l.reloadMu.RUnlock()
		l.reloadIfNeeded()
	}

	msg, _ := l.tryTr(trKey, trArgs...)
	return msg
}

func (l *locale) tryTr(trKey string, trArgs ...interface{}) (msg string, found bool) {
	trMsg := trKey

	if l.store.reloadMu != nil {
		l.store.reloadMu.RLock()
	}
	idx, ok := l.store.trKeyToIdxMap[trKey]
	if l.store.reloadMu != nil {
		l.store.reloadMu.RUnlock()
	}

	if ok {
		if msg, found = l.idxToMsgMap[idx]; found {
			trMsg = msg // use current translation
		} else if l.langName != l.store.defaultLang {

			// attempt to get the default language from the locale store
			if l.store.reloadMu != nil {
				l.store.reloadMu.RLock()
			}
			def, ok := l.store.localeMap[l.store.defaultLang]
			if l.store.reloadMu != nil {
				l.store.reloadMu.RUnlock()
			}

			if ok {
				if def.reloadMu != nil {
					def.reloadMu.RLock()
				}
				if msg, found = def.idxToMsgMap[idx]; found {
					trMsg = msg // use current translation
				}
				if def.reloadMu != nil {
					def.reloadMu.RUnlock()
				}
			}
		}
	}

	if !found && !setting.IsProd {
		log.Error("missing i18n translation key: %q", trKey)
	}

	if len(trArgs) == 0 {
		return trMsg, found
	}

	fmtArgs := make([]interface{}, 0, len(trArgs))
	for _, arg := range trArgs {
		val := reflect.ValueOf(arg)
		if val.Kind() == reflect.Slice {
			// before, it can accept Tr(lang, key, a, [b, c], d, [e, f]) as Sprintf(msg, a, b, c, d, e, f), it's an unstable behavior
			// now, we restrict the strange behavior and only support:
			// 1. Tr(lang, key, [slice-items]) as Sprintf(msg, items...)
			// 2. Tr(lang, key, args...) as Sprintf(msg, args...)
			if len(trArgs) == 1 {
				for i := 0; i < val.Len(); i++ {
					fmtArgs = append(fmtArgs, val.Index(i).Interface())
				}
			} else {
				log.Error("the args for i18n shouldn't contain uncertain slices, key=%q, args=%v", trKey, trArgs)
				break
			}
		} else {
			fmtArgs = append(fmtArgs, arg)
		}
	}

	return fmt.Sprintf(trMsg, fmtArgs...), found
}

// ResetDefaultLocales resets the current default locales
// NOTE: this is not synchronized
func ResetDefaultLocales(isProd bool) {
	DefaultLocales = NewLocaleStore(isProd)
}

// Tr use default locales to translate content to target language.
func Tr(lang, trKey string, trArgs ...interface{}) string {
	return DefaultLocales.Tr(lang, trKey, trArgs...)
}
